<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="计算机存储器，存储结构，虚拟内存，寄存器，CPU缓存">
<meta property="og:type" content="article">
<meta property="og:title" content="    计算机理论知识概念001">
<meta property="og:url" content="http://yoursite.com/2020/09/27/2020-09-28%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA%E7%9F%A5%E8%AF%86%E7%B3%BB%E5%88%97-1/index.html">
<meta property="og:site_name" content="Peiqin">
<meta property="og:description" content="计算机存储器，存储结构，虚拟内存，寄存器，CPU缓存">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://upload.wikimedia.org/wikipedia/commons/b/bf/CPU%E7%BC%93%E5%AD%98_00%E7%BC%93%E5%AD%98%E6%AE%B5%E7%BB%93%E6%9E%84.png">
<meta property="og:image" content="https://upload.wikimedia.org/wikipedia/commons/thumb/d/d3/CPU%E7%BC%93%E5%AD%98_01_%E8%BF%90%E4%BD%9C%E6%B5%81%E7%A8%8B.png/300px-CPU%E7%BC%93%E5%AD%98_01_%E8%BF%90%E4%BD%9C%E6%B5%81%E7%A8%8B.png">
<meta property="article:published_time" content="2020-09-27T14:09:32.747Z">
<meta property="article:modified_time" content="2020-09-27T14:43:20.070Z">
<meta property="article:author" content="peiqin">
<meta property="article:tag" content="work-skill">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://upload.wikimedia.org/wikipedia/commons/b/bf/CPU%E7%BC%93%E5%AD%98_00%E7%BC%93%E5%AD%98%E6%AE%B5%E7%BB%93%E6%9E%84.png">

<link rel="canonical" href="http://yoursite.com/2020/09/27/2020-09-28%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA%E7%9F%A5%E8%AF%86%E7%B3%BB%E5%88%97-1/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>    计算机理论知识概念001 | Peiqin</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Peiqin</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">每日更新公众号：众手</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>全部</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/09/27/2020-09-28%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA%E7%9F%A5%E8%AF%86%E7%B3%BB%E5%88%97-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/user.jpg">
      <meta itemprop="name" content="peiqin">
      <meta itemprop="description" content="任何东西都会是环环相扣">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Peiqin">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
              计算机理论知识概念001
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-09-27 22:09:32 / 修改时间：22:43:20" itemprop="dateCreated datePublished" datetime="2020-09-27T22:09:32+08:00">2020-09-27</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/computer-theory/" itemprop="url" rel="index"><span itemprop="name">computer theory</span></a>
                </span>
            </span>

          
            <span id="/2020/09/27/2020-09-28%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA%E7%9F%A5%E8%AF%86%E7%B3%BB%E5%88%97-1/" class="post-meta-item leancloud_visitors" data-flag-title="    计算机理论知识概念001" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2020/09/27/2020-09-28%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA%E7%9F%A5%E8%AF%86%E7%B3%BB%E5%88%97-1/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2020/09/27/2020-09-28%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA%E7%9F%A5%E8%AF%86%E7%B3%BB%E5%88%97-1/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>5.7k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>5 分钟</span>
            </span>
            <div class="post-description">计算机存储器，存储结构，虚拟内存，寄存器，CPU缓存</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <blockquote>
<p>内容来源于维基，相对有参考的价值，越是基础，越不能有半点差池。</p>
<p>计算机存储器，存储结构，虚拟内存，寄存器，CPU缓存</p>
</blockquote>
<h4 id="计算机存储器"><a href="#计算机存储器" class="headerlink" title="计算机存储器"></a>计算机存储器</h4><p><strong>计算机存储器</strong>（英语：Computer memory）是一种利用<a href="https://zh.m.wikipedia.org/wiki/半導體" target="_blank" rel="noopener">半导体</a>、磁性介质等技术制成的存储<a href="https://zh.m.wikipedia.org/wiki/資料" target="_blank" rel="noopener">资料</a>的电子设备。其<a href="https://zh.m.wikipedia.org/wiki/電子電路" target="_blank" rel="noopener">电子电路</a>中的资料以<a href="https://zh.m.wikipedia.org/wiki/二进制" target="_blank" rel="noopener">二进制</a>方式存储，不同存储器产品中基本单元的名称也不一样。</p>
<p>计算机存储器可分为内部存储器（又称内存或主存）和外部存储器，其中内存是CPU能直接寻址的储存空间，由半导体器件制成。内存的特点是访问速率快。我们平常使用的程序，如Windows操作系统、打字软件、游戏软件等，一般都是安装在硬盘等外部记忆体上的，但必须把它们调入内存中运行，才能真正使用其功能，我们平时输入一段文字，或玩一个游戏，其实都是在内存中进行的，数据产生后不断地由内存向外部记忆体进行读写。就好比在一个书房里，存放书籍的书架和书柜相当于电脑的外部记忆体，而我们工作的办公桌就是内存。通常我们把要永久保存的、大量的数据储存在外部记忆体上，而把一些临时的或少量的数据和程序放在内存上，当然内存的好坏会直接影响电脑的运行速度</p>
<h5 id="容量"><a href="#容量" class="headerlink" title="容量"></a>容量</h5><p>存储器以二进制计算容量，基本单位是<a href="https://zh.m.wikipedia.org/wiki/Byte" target="_blank" rel="noopener">Byte</a>：</p>
<ul>
<li>1 Kilobyte(KB) =1,024B=210B</li>
<li>1 Megabyte(MB)=1,024KiB=220B=1,048,576B</li>
<li>1 Gigabyte(GB)=1,024MiB=230B=1,073,741,824B</li>
<li>1 Terabyte(TB)=1,024GiB=240B=1,099,511,627,776B</li>
<li>1 Petabyte(PB)=1,024TiB=250B=1,125,899,906,842,624B</li>
<li>1 Exabyte(EB) =1,024PiB=260B=1,152,921,504,606,846,976B</li>
<li>1 Zettabyte(ZB)=1,024EiB=270B</li>
<li>1 Yottabyte(YB)=1,024ZiB=280B</li>
</ul>
<p>根据<a href="https://zh.m.wikipedia.org/wiki/电气电子工程师协会" target="_blank" rel="noopener">电气电子工程师协会</a>（IEEE 1541）和<a href="https://zh.m.wikipedia.org/wiki/歐洲聯盟" target="_blank" rel="noopener">欧洲联盟</a>(HD 60027-2:2003-03)的标准，<a href="https://zh.m.wikipedia.org/wiki/二进制乘数词头" target="_blank" rel="noopener">二进制乘数词头</a>的缩写为“Ki”、“Mi”、“Gi”，以避免与<a href="https://zh.m.wikipedia.org/wiki/国际单位制" target="_blank" rel="noopener">SI Unit</a>国际单位制混淆。但二进制乘数词头没有广泛被制造业和个人采用，标示为4GB的内存实际上已经是4GiB，但标示为4.7GB的<a href="https://zh.m.wikipedia.org/wiki/DVD" target="_blank" rel="noopener">DVD</a>实际上是4.37GiB。</p>
<p>对于32位的操作系统，最多可使用232个地址，即是4GiB。<a href="https://zh.m.wikipedia.org/wiki/物理地址扩展" target="_blank" rel="noopener">物理地址扩展</a>可以让处理器在32位操作系统访问超过4GiB存储器，发展64位处理器则是根本的解决方法，但<a href="https://zh.m.wikipedia.org/wiki/作業系統" target="_blank" rel="noopener">操作系统</a>、<a href="https://zh.m.wikipedia.org/wiki/驅動程式" target="_blank" rel="noopener">驱动程序</a>和<a href="https://zh.m.wikipedia.org/wiki/應用程式" target="_blank" rel="noopener">应用程序</a>都会有<a href="https://zh.m.wikipedia.org/wiki/相容性" target="_blank" rel="noopener">兼容性</a>问题。</p>
<h5 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h5><p>计算机存储器可以根据存储能力与电源的关系可以分为以下两类：</p>
<h6 id="易失性存储器"><a href="#易失性存储器" class="headerlink" title="易失性存储器"></a>易失性存储器</h6><p>易失性存储器（Volatile memory）是指当电源供应中断后，存储器所存储的资料便会消失的存储器。主要有以下的类型：</p>
<p><a href="https://zh.m.wikipedia.org/wiki/隨機存取記憶體" target="_blank" rel="noopener">随机存取存储器</a></p>
<ul>
<li><a href="https://zh.m.wikipedia.org/wiki/動態隨機存取記憶體" target="_blank" rel="noopener">动态随机存取存储器</a>，英文缩写写作DRAM，一般每个单元由一个晶体管和一个电容组成（后者在集成电路上可以用两个晶体管模拟）。特点是单元占用资源和空间小，速度比SRAM慢，需要刷新。一般计算机<a href="https://zh.m.wikipedia.org/wiki/主内存" target="_blank" rel="noopener">主内存</a>即由DRAM组成。在PC上，DRAM以内存条的方式出现，DRAM颗粒多为4位或8位位宽，而载有多个颗粒的单根内存条的位宽为64位。</li>
<li><a href="https://zh.m.wikipedia.org/wiki/静态随机存取存储器" target="_blank" rel="noopener">静态随机存取存储器</a>，英文缩写写作SRAM，一般每个单元由6个晶体管组成，但近来也出现由8个晶体管构成的SRAM单元。特点是速度快，但单元占用资源比DRAM多。一般<a href="https://zh.m.wikipedia.org/wiki/CPU" target="_blank" rel="noopener">CPU</a>的<a href="https://zh.m.wikipedia.org/wiki/CPU缓存" target="_blank" rel="noopener">CPU缓存</a>即由SRAM构成。</li>
</ul>
<h6 id="非易失性存储器"><a href="#非易失性存储器" class="headerlink" title="非易失性存储器"></a>非易失性存储器</h6><p>非易失性存储器（Non-volatile memory）是指即使电源供应中断，存储器所存储的资料并不会消失，重新供电后，就能够读取存储器中的资料。 主要种类如下：</p>
<ul>
<li><p>只读存储器</p>
<p>（ROM）</p>
<ul>
<li><a href="https://zh.m.wikipedia.org/wiki/可規化式唯讀記憶體" target="_blank" rel="noopener">可编程式只读存储器</a>（PROM）</li>
<li><a href="https://zh.m.wikipedia.org/wiki/可擦除可規劃式唯讀記憶體" target="_blank" rel="noopener">可擦除可规划式只读存储器</a>（EPROM）</li>
<li><a href="https://zh.m.wikipedia.org/wiki/電子抹除式可複寫唯讀記憶體" target="_blank" rel="noopener">电子抹除式可复写只读存储器</a>（EEPROM）</li>
<li><a href="https://zh.m.wikipedia.org/wiki/快閃記憶體" target="_blank" rel="noopener">Flash</a> ROM</li>
</ul>
</li>
<li><p>磁存储</p>
<ul>
<li><a href="https://zh.m.wikipedia.org/wiki/硬碟" target="_blank" rel="noopener">硬盘</a></li>
<li><a href="https://zh.m.wikipedia.org/wiki/軟碟" target="_blank" rel="noopener">软盘</a></li>
<li><a href="https://zh.m.wikipedia.org/wiki/磁帶" target="_blank" rel="noopener">磁带</a></li>
</ul>
</li>
<li><p><a href="https://zh.m.wikipedia.org/wiki/3D_XPoint" target="_blank" rel="noopener">3D XPoint</a></p>
</li>
<li><p><a href="https://zh.m.wikipedia.org/wiki/固态硬盘" target="_blank" rel="noopener">固态硬盘</a></p>
</li>
<li><p>光存储</p>
<ul>
<li><a href="https://zh.m.wikipedia.org/wiki/光碟" target="_blank" rel="noopener">光盘</a></li>
</ul>
</li>
</ul>
<h4 id="存储层次"><a href="#存储层次" class="headerlink" title="存储层次"></a>存储层次</h4><p><strong>存储层次</strong>是在<a href="https://zh.m.wikipedia.org/wiki/電腦架構" target="_blank" rel="noopener">计算机体系结构</a>下<a href="https://zh.m.wikipedia.org/wiki/儲存系統" target="_blank" rel="noopener">存储系统</a>层次结构的排列顺序。每一层于下一层相比都拥有较高的<a href="https://zh.m.wikipedia.org/wiki/速度" target="_blank" rel="noopener">速度</a>和较低<a href="https://zh.m.wikipedia.org/w/index.php?title=延遲性&action=edit&redlink=1" target="_blank" rel="noopener">延迟性</a>，以及较小的容量（也有少量例外，如AMD早期的<a href="https://zh.m.wikipedia.org/wiki/Duron" target="_blank" rel="noopener">Duron</a> CPU）。大部分现今的<a href="https://zh.m.wikipedia.org/wiki/中央處理器" target="_blank" rel="noopener">中央处理器</a>的速度都非常的快。大部分程序工作量需要存储器访问。由于<a href="https://zh.m.wikipedia.org/wiki/快取" target="_blank" rel="noopener">高速缓存</a>的效率和存储器传输位于层次结构中的不同等级，所以实际上会限制处理的速度，导致中央处理器花费大量的时间等待存储器I/O完成工作。</p>
<p>大部分电脑中的存储层次如下四层：</p>
<p>1) <a href="https://zh.m.wikipedia.org/wiki/暫存器" target="_blank" rel="noopener">寄存器</a>–可能是最快的访问。在32位处理器，每个寄存器就是32位。<a href="https://zh.m.wikipedia.org/wiki/X86" target="_blank" rel="noopener">x86</a>处理器共有16个寄存器。</p>
<p>2) <a href="https://zh.m.wikipedia.org/wiki/快取" target="_blank" rel="noopener">高速缓存</a>（L1-L3: <a href="https://zh.m.wikipedia.org/wiki/靜態隨機存取記憶體" target="_blank" rel="noopener">SRAM</a>）</p>
<p>3) <a href="https://zh.m.wikipedia.org/wiki/隨機存取記憶體" target="_blank" rel="noopener">主存</a>（<a href="https://zh.m.wikipedia.org/wiki/DRAM" target="_blank" rel="noopener">DRAM</a>）–访问需要几百个周期，可以大到数十GB。</p>
<p>4) <a href="https://zh.m.wikipedia.org/wiki/磁碟儲存" target="_blank" rel="noopener">磁盘存储</a>–需要成千上百个周期，容量非常大。</p>
<h4 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h4><p><strong>虚拟内存</strong>是计算机系统内存管理的一种技术。它使得应用程序认为它拥有连续可用的内存（一个连续完整的地址空间），而实际上，它通常是被分隔成多个物理内存碎片，还有部分暂时存储在外部磁盘存储器上，在需要时进行数据交换。与没有使用虚拟内存技术的系统相比，使用这种技术的系统使得大型程序的编写变得更容易，对真正的<a href="https://zh.m.wikipedia.org/wiki/物理内存" target="_blank" rel="noopener">物理内存</a>（例如<a href="https://zh.m.wikipedia.org/wiki/隨機存取記憶體" target="_blank" rel="noopener">RAM</a>）的使用也更有效率。</p>
<p>注意：<strong>虚拟内存</strong>不只是“用磁盘空间来扩展物理内存”的意思——这只是扩充<a href="https://zh.m.wikipedia.org/wiki/記憶體階層" target="_blank" rel="noopener">内存级别</a>以使其包含<a href="https://zh.m.wikipedia.org/wiki/硬盘驱动器" target="_blank" rel="noopener">硬盘驱动器</a>而已。把内存扩展到磁盘只是使用虚拟内存技术的一个结果，它的作用也可以通过<a href="https://zh.m.wikipedia.org/wiki/覆盖_(编程)" target="_blank" rel="noopener">覆盖</a>或者把处于不活动状态的程序以及它们的数据全部交换到磁盘上等方式来实现。对虚拟内存的定义是基于对<a href="https://zh.m.wikipedia.org/wiki/地址空间" target="_blank" rel="noopener">地址空间</a>的重定义的，即把地址空间定义为“连续的虚拟内存地址”，以借此“欺骗”程序，使它们以为自己正在使用一大块的“连续”地址。</p>
<p>现代所有用于一般应用的<a href="https://zh.m.wikipedia.org/wiki/操作系统" target="_blank" rel="noopener">操作系统</a>都对普通的应用程序使用虚拟内存技术，例如文字处理软件，电子制表软件，多媒体播放器等等。老一些的操作系统，如<a href="https://zh.m.wikipedia.org/wiki/DOS" target="_blank" rel="noopener">DOS</a>和1980年代的<a href="https://zh.m.wikipedia.org/wiki/Windows" target="_blank" rel="noopener">Windows</a>，或者那些1960年代的<a href="https://zh.m.wikipedia.org/wiki/大型机" target="_blank" rel="noopener">大型机</a>，一般都没有虚拟内存的功能——但是<a href="https://zh.m.wikipedia.org/w/index.php?title=Atlas_(電腦)&action=edit&redlink=1" target="_blank" rel="noopener">Atlas</a>（英语：<a href="https://en.wikipedia.org/wiki/Atlas_(computer)" target="_blank" rel="noopener">Atlas_(computer)</a>），<a href="https://zh.m.wikipedia.org/w/index.php?title=B5000&action=edit&redlink=1" target="_blank" rel="noopener">B5000</a>（英语：<a href="https://en.wikipedia.org/wiki/Burroughs_large_systems#B5000" target="_blank" rel="noopener">Burroughs_large_systems#B5000</a>）和<a href="https://zh.m.wikipedia.org/wiki/苹果" target="_blank" rel="noopener">苹果公司</a>的<a href="https://zh.m.wikipedia.org/wiki/Apple_Lisa" target="_blank" rel="noopener">Lisa</a>都是很值得注意的例外。<a href="https://zh.m.wikipedia.org/wiki/虚拟内存#cite_note-1" target="_blank" rel="noopener">[1]</a></p>
<p>那些需要快速访问或者反应时间非常一致的<a href="https://zh.m.wikipedia.org/wiki/嵌入式" target="_blank" rel="noopener">嵌入式</a>系统，和其他的具有特殊应用的计算机系统，可能会为了避免让<a href="https://zh.m.wikipedia.org/wiki/确定性算法" target="_blank" rel="noopener">运算结果的可预测性</a>降低，而选择不使用虚拟内存。</p>
<h4 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h4><p><strong>寄存器</strong>（Register）是<a href="https://zh.m.wikipedia.org/wiki/中央處理器" target="_blank" rel="noopener">中央处理器</a>内用来暂存指令、<a href="https://zh.m.wikipedia.org/wiki/數據" target="_blank" rel="noopener">数据</a>和<a href="https://zh.m.wikipedia.org/wiki/内存地址" target="_blank" rel="noopener">地址</a>的<a href="https://zh.m.wikipedia.org/wiki/電腦記憶體" target="_blank" rel="noopener">电脑存储器</a>。寄存器的存贮容量有限，读写速度非常快。在<a href="https://zh.m.wikipedia.org/wiki/電腦架構" target="_blank" rel="noopener">计算机体系结构</a>里，寄存器存储在已知时间点所作计算的中间结果，通过快速地访问数据来加速<a href="https://zh.m.wikipedia.org/wiki/電腦程式" target="_blank" rel="noopener">计算机程序</a>的运行。</p>
<p>寄存器位于<a href="https://zh.m.wikipedia.org/wiki/記憶體階層" target="_blank" rel="noopener">存储器层次结构</a>的最顶端，也是CPU可以读写的最快的存储器。寄存器通常都是以他们可以保存的<a href="https://zh.m.wikipedia.org/wiki/位元" target="_blank" rel="noopener">比特</a>数量来计量，举例来说，一个<a href="https://zh.m.wikipedia.org/wiki/8位元" target="_blank" rel="noopener">8位</a>寄存器或<a href="https://zh.m.wikipedia.org/wiki/32位元" target="_blank" rel="noopener">32位</a>寄存器。在中央处理器中，包含寄存器的部件有<a href="https://zh.m.wikipedia.org/wiki/指令寄存器" target="_blank" rel="noopener">指令寄存器</a>（IR）、<a href="https://zh.m.wikipedia.org/wiki/程序計數器" target="_blank" rel="noopener">程序计数器</a>和<a href="https://zh.m.wikipedia.org/wiki/累加器" target="_blank" rel="noopener">累加器</a>。寄存器现在都以<a href="https://zh.m.wikipedia.org/w/index.php?title=暫存器陣列&action=edit&redlink=1" target="_blank" rel="noopener">寄存器数组</a>的方式来实现，但是他们也可能使用单独的<a href="https://zh.m.wikipedia.org/wiki/正反器" target="_blank" rel="noopener">触发器</a>、高速的<a href="https://zh.m.wikipedia.org/w/index.php?title=核心記憶體&action=edit&redlink=1" target="_blank" rel="noopener">核心存储器</a>、<a href="https://zh.m.wikipedia.org/w/index.php?title=薄膜記憶體&action=edit&redlink=1" target="_blank" rel="noopener">薄膜存储器</a>以及在数种机器上的其他方式来实现出来。</p>
<p><strong>寄存器</strong>也可以指代由一个<a href="https://zh.m.wikipedia.org/wiki/指令" target="_blank" rel="noopener">指令</a>之输出或输入可以直接索引到的寄存器组群，这些寄存器的更确切的名称为“架构寄存器”。例如，<a href="https://zh.m.wikipedia.org/wiki/X86" target="_blank" rel="noopener">x86</a>指令集定义八个32位寄存器的集合，但一个实现<a href="https://zh.m.wikipedia.org/wiki/X86" target="_blank" rel="noopener">x86</a><a href="https://zh.m.wikipedia.org/wiki/指令集" target="_blank" rel="noopener">指令集</a>的<a href="https://zh.m.wikipedia.org/wiki/CPU" target="_blank" rel="noopener">CPU</a>内部可能会有八个以上的寄存器。</p>
<h6 id="寄存器的种类"><a href="#寄存器的种类" class="headerlink" title="寄存器的种类"></a>寄存器的种类</h6><p>资料寄存器</p>
<p>用来存储<a href="https://zh.m.wikipedia.org/wiki/整數" target="_blank" rel="noopener">整数</a>数字（参考以下的浮点寄存器）。在某些简单（或旧）的CPU，特别的资料寄存器是用于数学计算的<a href="https://zh.m.wikipedia.org/wiki/累加器" target="_blank" rel="noopener">累加器</a>。</p>
<p>地址寄存器</p>
<p>持有存储器地址，以及用来访问<a href="https://zh.m.wikipedia.org/wiki/記憶體" target="_blank" rel="noopener">存储器</a>。在某些简单/旧的CPU里，特别的地址寄存器是<a href="https://zh.m.wikipedia.org/w/index.php?title=索引暫存器&action=edit&redlink=1" target="_blank" rel="noopener">索引寄存器</a>（可能出现一个或多个）。</p>
<p>通用目的寄存器</p>
<p>（<strong>GPR</strong>s）- 可以保存资料或地址两者，也就是说他们是结合 资料/地址 寄存器的功用。</p>
<p>浮点寄存器</p>
<p>（<strong>FPR</strong>s）- 用来存储<a href="https://zh.m.wikipedia.org/wiki/浮点" target="_blank" rel="noopener">浮点</a>数字。</p>
<p>常量寄存器</p>
<p>用来持有只读的数值（例如0、1、圆周率等等）。由于“其中的值不可更改”这一特殊性质，这些寄存器未必会有实体的硬件电路相对应，例如将从零常数寄存器读的操作实现为接通目标寄存器的<a href="https://zh.m.wikipedia.org/wiki/下拉电阻" target="_blank" rel="noopener">下拉电阻</a>。</p>
<p>一般而言，即使真正在硬件中放置常数寄存器也未必会是出于体系结构理论上的考虑，而很可能是由<a href="https://zh.m.wikipedia.org/wiki/硬件描述语言" target="_blank" rel="noopener">硬件描述语言</a>为了简化操作而自动生成的电路。</p>
<p>向量寄存器</p>
<p>用来存储由向量处理器运行<a href="https://zh.m.wikipedia.org/wiki/SIMD" target="_blank" rel="noopener">SIMD</a>指令所得到的资料。</p>
<p>特殊目的寄存器</p>
<p>存储CPU内部的资料，像是<a href="https://zh.m.wikipedia.org/wiki/程式計數器" target="_blank" rel="noopener">程序计数器</a>（或称为<a href="https://zh.m.wikipedia.org/wiki/指令指针" target="_blank" rel="noopener">指令指针</a>），<a href="https://zh.m.wikipedia.org/wiki/堆栈" target="_blank" rel="noopener">堆栈寄存器</a>，以及<a href="https://zh.m.wikipedia.org/w/index.php?title=狀態暫存器&action=edit&redlink=1" target="_blank" rel="noopener">状态寄存器</a>（或称微处理器状态字组）。</p>
<ul>
<li><p><strong><a href="https://zh.m.wikipedia.org/wiki/指令寄存器" target="_blank" rel="noopener">指令寄存器</a></strong> - 存储现在正在被运行的指令</p>
</li>
<li><p><strong><a href="https://zh.m.wikipedia.org/w/index.php?title=变址寄存器&action=edit&redlink=1" target="_blank" rel="noopener">变址寄存器</a>（英语：<a href="https://en.wikipedia.org/wiki/Index_register" target="_blank" rel="noopener">Index_register</a>）</strong> - 是在程序运行时用来更改操作数地址之用。</p>
</li>
<li><p>在某些架构下，<strong>模式指示寄存器</strong>（也称为“机器指示寄存器”）存储和设置跟处理器自己有关的资料。由于他们的意图目的是附加到特定处理器的设计，因此他们并不被预期会成微处理器世代之间保留的标准。</p>
</li>
<li><p>有关从</p>
<p>随机存取存储器</p>
<p>提取信息的寄存器与CPU（位于不同芯片的存储寄存器集合）</p>
<ul>
<li><a href="https://zh.m.wikipedia.org/w/index.php?title=記憶體緩衝寄存器&action=edit&redlink=1" target="_blank" rel="noopener">存储器缓冲寄存器</a>（英语：<a href="https://en.wikipedia.org/wiki/Memory_buffer_register" target="_blank" rel="noopener">Memory buffer register</a>）</li>
<li><a href="https://zh.m.wikipedia.org/wiki/記憶體資料寄存器" target="_blank" rel="noopener">存储器资料寄存器</a></li>
<li><a href="https://zh.m.wikipedia.org/w/index.php?title=記憶體位址寄存器&action=edit&redlink=1" target="_blank" rel="noopener">存储器地址寄存器</a>（英语：<a href="https://en.wikipedia.org/wiki/Memory_address_register" target="_blank" rel="noopener">Memory address register</a>）</li>
<li><a href="https://zh.m.wikipedia.org/w/index.php?title=記憶體型態範圍寄存器&action=edit&redlink=1" target="_blank" rel="noopener">存储器类型范围寄存器</a>（英语：<a href="https://en.wikipedia.org/wiki/Memory_Type_Range_Registers" target="_blank" rel="noopener">Memory Type Range Registers</a>）</li>
</ul>
</li>
</ul>
<blockquote>
<p>cup缓存是个复杂的概率，以下暂时列出基本描述，是不完整的，读者要注意一下。</p>
</blockquote>
<h4 id="cup缓存"><a href="#cup缓存" class="headerlink" title="cup缓存"></a>cup缓存</h4><p>在<a href="https://zh.m.wikipedia.org/wiki/计算机" target="_blank" rel="noopener">计算机</a>系统中，<strong>CPU高速缓存</strong>（英语：CPU Cache，在本文中简称缓存）是用于减少<a href="https://zh.m.wikipedia.org/wiki/中央处理器" target="_blank" rel="noopener">处理器</a>访问内存所需平均时间的部件。在金字塔式<a href="https://zh.m.wikipedia.org/w/index.php?title=存储体系&action=edit&redlink=1" target="_blank" rel="noopener">存储体系</a>中它位于自顶向下的第二层，仅次于<a href="https://zh.m.wikipedia.org/wiki/寄存器" target="_blank" rel="noopener">CPU寄存器</a>。其容量远小于<a href="https://zh.m.wikipedia.org/wiki/内存" target="_blank" rel="noopener">内存</a>，但速度却可以接近处理器的频率。</p>
<p>当处理器发出内存访问请求时，会先查看缓存内是否有请求数据。如果存在（命中），则不经访问内存直接返回该数据；如果不存在（失效），则要先把内存中的相应数据载入缓存，再将其返回处理器。</p>
<p>缓存之所以有效，主要是因为程序运行时对内存的访问呈现局部性（Locality）特征。这种局部性既包括空间局部性（Spatial Locality），也包括时间局部性（Temporal Locality）。有效利用这种局部性，缓存可以达到极高的命中率。</p>
<p>在处理器看来，缓存是一个透明部件。因此，程序员通常无法直接干预对缓存的操作。但是，确实可以根据缓存的特点对程序代码实施特定优化，从而更好地利用缓存。</p>
<h5 id="基本描叙"><a href="#基本描叙" class="headerlink" title="基本描叙"></a>基本描叙</h5><h6 id="缓存的存储结构"><a href="#缓存的存储结构" class="headerlink" title="缓存的存储结构"></a>缓存的存储结构</h6><p>结构上，一个直接映射（Direct Mapped）缓存由若干缓存块（Cache Block，或Cache Line）构成。每个缓存块存储具有连续内存地址的若干个存储单元。在32位计算机上这通常是一个双<a href="https://zh.m.wikipedia.org/wiki/字_(计算机)" target="_blank" rel="noopener">字</a>（dword），即四个字节。因此，每个双字具有唯一的块内偏移量。</p>
<p>每个缓存块有一个索引（Index），它一般是内存地址的低端部分，但不含块内偏移和字节偏移所占的最低若干位。一个数据总量为4KB、缓存块大小为16B的直接映射缓存一共有256个缓存块，其索引范围为0到255。使用一个简单的移位函数，就可以求得任意内存地址对应的缓存块的索引。由于这是一种多对一映射，必须在存储一段数据的同时标示出这些数据在内存中的确切位置。所以每个缓存块都配有一个标签（Tag）。拼接标签值和此缓存块的索引，即可求得缓存块的内存地址。如果再加上块内偏移，就能得出任意一块数据的对应内存地址。</p>
<p>因此，在缓存大小不变的情况下，缓存块大小和缓存块总数成反比关系。下图中所示的缓存块来自一个数据总量为4KB、每个缓存块大小为16B的直接映射缓存，其标签长度为20bits。</p>
<p><a href="https://zh.m.wikipedia.org/wiki/File:CPU缓存_00缓存段结构.png" target="_blank" rel="noopener"><img src="https://upload.wikimedia.org/wikipedia/commons/b/bf/CPU%E7%BC%93%E5%AD%98_00%E7%BC%93%E5%AD%98%E6%AE%B5%E7%BB%93%E6%9E%84.png" alt="一个大小为16字节的缓存块。从属于一个数据总量为4KB的直接映射缓存。"></a></p>
<p>此外，每个缓存块还可对应若干标志位，包括有效位（valid bit）、脏位（dirty bit）、使用位（use bit）等。这些位在保证正确性、排除冲突、优化性能等方面起着重要作用。</p>
<h6 id="运作流程"><a href="#运作流程" class="headerlink" title="运作流程"></a>运作流程</h6><p>下面简要描述一个假想的直接映射缓存的工作流程。这个缓存共有四个缓存块，每个块16字节，即4个字，因此共有64字节存储空间。使用写回（Write back）策略以保证数据一致性。</p>
<p><a href="https://zh.m.wikipedia.org/wiki/File:CPU缓存_01_运作流程.png" target="_blank" rel="noopener"><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/d/d3/CPU%E7%BC%93%E5%AD%98_01_%E8%BF%90%E4%BD%9C%E6%B5%81%E7%A8%8B.png/300px-CPU%E7%BC%93%E5%AD%98_01_%E8%BF%90%E4%BD%9C%E6%B5%81%E7%A8%8B.png" alt="img"></a></p>
<p>CPU缓存的运作流程（注意内存左侧给出的地址是字地址而不是字节地址）</p>
<p>系统启动时，缓存内没有任何数据。之后，数据逐渐被载入或换出缓存。假设在此后某一时间点，缓存和内存布局如右图所示。此时，若处理器执行数据读取指令，控制逻辑依如下流程：</p>
<ol>
<li>(将地址由高至低划分为四个部分：标签、索引、块内偏移、字节偏移。其中块内偏移和字节偏移各占两位，后者在以下操作中不使用。)</li>
<li>用索引定位到相应的缓存块。</li>
<li>用标签尝试匹配该缓存块的对应标签值。如果存在这样的匹配，称为命中（Hit）；否则称为未命中（Miss）。</li>
<li>如命中，用块内偏移将已定位缓存块内的特定数据段取出，送回处理器。</li>
<li>如未命中，先用此块地址（标签+索引）从内存读取数据并载入到当前缓存块，再用块内偏移将位于此块内的特定数据单元取出，送回处理器。这里要注意的是，（1）读入的数据会冲掉之前的内容。为保证数据一致性，必须先将数据块内的现有内容写回内存。（2）尽管处理器请求的只是一个字，缓存仍必须在读取的时候把整个数据块都填充满。（3）缓存的读取是按缓存块大小为边界对齐的。对于大小为16字节的缓存块，任何因为0x0000、或0x0001、或0x0002、或0x0003造成的未命中，都会导致位于内存0x0000—0x0003的全部四个字被读入块中。</li>
</ol>
<p>在右图中，如此时处理器请求的地址在0x0020到0x0023之间，或在0x0004到0x0007之间，或在0x0528到0x052B之间，或在0x05EC到0x05EF之间，均会命中。其余地址则全部未命中。</p>
<p>而处理器执行数据写入指令时，控制逻辑依如下流程：</p>
<ol>
<li>用索引定位到相应的缓存块。</li>
<li>用标签尝试匹配该缓存块的对应标签值。其结果为命中或未命中。</li>
<li>如命中，用块内偏移定位此块内的目标字。然后直接改写这个字。</li>
<li>如未命中，依系统设计不同可有两种处理策略，分别称为<a href="https://zh.m.wikipedia.org/zh-hans/CPU缓存#按写分配与不按写分配" target="_blank" rel="noopener">按写分配</a>（Write allocate）和<a href="https://zh.m.wikipedia.org/zh-hans/CPU缓存#按写分配与不按写分配" target="_blank" rel="noopener">不按写分配</a>（No-write allocate）。如果是按写分配，则先如处理读未命中一样，将未命中数据读入缓存，然后再将数据写到被读入的字单元。如果是不按写分配，则直接将数据写回内存。</li>
</ol>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/work-skill/" rel="tag"># work-skill</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/09/27/2020-09-27%E5%A4%A7%E8%84%91%E7%A5%9E%E7%BB%8F%E8%AE%A4%E7%9F%A5%E7%A7%91%E5%AD%A6%E7%B3%BB%E5%88%97-2/" rel="prev" title="    大脑神经认知科学系列-2">
      <i class="fa fa-chevron-left"></i>     大脑神经认知科学系列-2
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-4"><a class="nav-link" href="#计算机存储器"><span class="nav-number">1.</span> <span class="nav-text">计算机存储器</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#容量"><span class="nav-number">1.1.</span> <span class="nav-text">容量</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#分类"><span class="nav-number">1.2.</span> <span class="nav-text">分类</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#易失性存储器"><span class="nav-number">1.2.1.</span> <span class="nav-text">易失性存储器</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#非易失性存储器"><span class="nav-number">1.2.2.</span> <span class="nav-text">非易失性存储器</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#存储层次"><span class="nav-number">2.</span> <span class="nav-text">存储层次</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#虚拟内存"><span class="nav-number">3.</span> <span class="nav-text">虚拟内存</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#寄存器"><span class="nav-number">4.</span> <span class="nav-text">寄存器</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#寄存器的种类"><span class="nav-number">4.0.1.</span> <span class="nav-text">寄存器的种类</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#cup缓存"><span class="nav-number">5.</span> <span class="nav-text">cup缓存</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#基本描叙"><span class="nav-number">5.1.</span> <span class="nav-text">基本描叙</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#缓存的存储结构"><span class="nav-number">5.1.1.</span> <span class="nav-text">缓存的存储结构</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#运作流程"><span class="nav-number">5.1.2.</span> <span class="nav-text">运作流程</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="peiqin"
      src="/images/user.jpg">
  <p class="site-author-name" itemprop="name">peiqin</p>
  <div class="site-description" itemprop="description">任何东西都会是环环相扣</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">28</span>
          <span class="site-state-item-name">文章</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">14</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">peiqin</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">74k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">1:07</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'fpupK04X0TovxqxBgXa0pk7a-gzGzoHsz',
      appKey     : '5ffeQdQDuDVEeI0EMpomu4AV',
      placeholder: "Just go go",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : true,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
